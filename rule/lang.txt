# comment
defrule правило_сказуемое {
# condition
    condition {
# match(<fact name>, <attribute name 1>:<value>, <attribute name 2>:<value>, ...)
    match(сказуемое, вариант:?вариант, значение:?значение, позиция:?позиция, часть_речи:глагол, склонение:?склонение, лицо:?лицо)
# can be selected many facts
    };
# =>
#consequence
    consequence {
# циклическая обработка для каждого факта из найденного списка
# текущий факт в переменной ?current_fact
# обращение к атрибутам текущего факта:
# 	уникальный идентификатор - ?current_fact:ID
# 	имя факта ?current_fact:Name
#	к пользовательскому атрибуту факта ?current_fact:<имя атрибута>
# добавляет новый факт. первый аргумент - переменная в которую пападет новый факт
        add(?fact, сказуемое, тип:добавка, вариант:?вариант, значение:?значение, позиция:?позиция, часть_речи:глагол, склонение:?склонение, лицо:?лицо);
# удаляет факт из памяти по идентификатору
        delete(?current_fact:ID);
# печатает факт по идентификатору
        print(?current_fact:ID);
# вызов применения правила
        call(правило_сказуемое);
# предикат равенства значения атрибута и константы
# ?<variable name>:<attribute name> == <const>
# предикат равенства значения атрибута и значения атрибута
# ?<variable name 1>:<attribute name> == ?<variable name 2>:<attribute name>
        if current_fact:лицо == "1е" { 
            add(?fact, новый_факт, вариант:?вариант, значение:?значение);
#<list of operators> 
        };
    };
};